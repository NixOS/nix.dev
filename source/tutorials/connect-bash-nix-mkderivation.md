# Connecting Bash to Nix and mkDerivation

This tutorial was originally a [blog post by Ross Light].

[blog post by Ross Light]:https://www.zombiezen.com/blog/2023/03/connecting-bash-to-nix/

This tutorial zooms in on the core derivation abstraction. This way you should be able to better understand how Nix derivations work and how they relate to Bash scripts.

## What do you need?
- Familiarity with Bash scripting
- Ability to compile Unix software, especially C
- A {ref}`Nix installation <install-nix>` to run the examples
- A reliable internet connection to download ~100MB of nix-packages.

## Hello World
The starting point is to create a Hello World derivation using only the Nix language builtins. 

The starting point is a very simple shell script that takes the contents of a greeting environment variable and saves it into the file named by the environment variable out. Copy the following script into a file named greet.sh:

```{code-block} bash
#!/bin/sh
echo "$greeting" > "$out"
```

When this file is created, make it executable by running: `chmod +x greet.sh`.

To create the derivation in `hello.nix`:

```{code-block} nix
builtins.derivation {
  name = "hello.txt";
  builder = ./greet.sh;
  system = builtins.currentSystem;

  greeting = "Hello, World!";
  }
```

Files ending in `.nix` are expressions written in the Nix programming language. 

:::{dropdown} Detailed explanation of hello.nix line by line

1. `builtins.derivation` is a built-in Nix function. The opening brace starts an attribute set: a data type very similar to a JavaScript/JSON object or a Python dictionary. The attribute set is passed to the `derivation` function as its argument.
2. `name` is the full name of the derivation. It's a required argument for the `derivation` function.  `name` is used as part of the build output path (called a store path) when the derivation is built.
3. `builder` is the program that nix-build will run when the derivation is built. It's also required for the `derivation` function. It is typically a shell script, but could be the path to any Unix executable.
4. `system` is a string specifying the Nix system type that the build can occur on. It's the last required argument for the `derivation` function. `builtins.currentSystem` is used here to say "this derivation can build on whatever system that is currently running".
5. Any other attributes passed along to the `derivation` are passed along as environment variables to the builder. In this case, the `greeting` environment variable is set to "Hello, World!".
6. The closing brace ends the attribute set literal.
:::

To build the derivation, run:
```shell-session
$ nix-build hello.nix
this derivation will be built:
  /nix/store/ymhh65wy3nr7b9w8jl9kqavz9bq57fhp-hello.txt.drv
building '/nix/store/ymhh65wy3nr7b9w8jl9kqavz9bq57fhp-hello.txt.drv'...
/nix/store/8ny033mhdz8c7187wskdz2k9n83sifbz-hello.txt
```

when the build is successful, the last line of the output will be the store path, which is auto-generated by Nix. This is the same path that will be sent to the `builder` program as the `$out` environment variable. As a convenience, the `nix-build` command will also create a symlink to the store path in the current directory with the name `result`.

The symlink can be inspected:
```shell-session
$ readlink result
/nix/store/8ny033mhdz8c7187wskdz2k9n83sifbz-hello.txt
$ cat /nix/store/8ny033mhdz8c7187wskdz2k9n83sifbz-hello.txt
Hello, World!
```

:::{dropdown} Detailed explanation
the `8ny033mhdz8c7187wskdz2k9n83sifbz` part of the store path is based on the hash of the derivation and its inputs. If you are following along on a `x86_64-linux` system, you will get the same hashes. This is a key part of how Nix can reuse built derivations across machines. If you are using a non-Intel or non_linx machine, the hashed will be different because the `system` is different.
:::

Above `nix-build` was used to build a text file. Below `nix-build` will be used to create some more complex build outputs.

## Building and using derivations for programs
Below is a derivation that generates a shell script rather than a text file. The convention for derivations that bundle up programs is to create a small version of the [Filesystem Hierarchy Standard] at the store path. That means that an `$out/bin` directory shall be created, and the shell script shall be placed there.

[Filesystem Hierarchy Standard]: https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard


First create a new builder script named `build-greeter-script.sh`:
```{code-block} bash

#!/bin/sh

set -e
mkdir -p "$out/bin"
echo "#!/bin/sh" > "$out/bin/hello"
echo "echo '$greeting'" >> "$out/bin/hello"^
chmod +x "$out/bin/hello"
```
Run `chmod +x build-greeter-script.sh` to make the script executable.
Next make a new derivation named `hello-script.nix` (very similar to the last one):
```{code-block} nix
# First attempt, not the final version:

builtins.derivation {
    name = "hello";
    builder = ./build-greeter-script.sh;
    system = builtins.currentSystem;

    greeting = "Hello, World!";
}
```

Build with `nix-build` as done before:
```shell-session
$ nix-build hello-script.nix
this derivation will be built:
  /nix/store/d4yfycw4zb33d5syhzarcm7lcmk6y6yn-hello.drv
building '/nix/store/d4yfycw4zb33d5syhzarcm7lcmk6y6yn-hello.drv'...
/nix/store/yki5b3vqfzpwvkr6k7iwaxpmckfk3l2b-build-greeter-script.sh: line 4: mkdir: not found
error: builder for '/nix/store/d4yfycw4zb33d5syhzarcm7lcmk6y6yn-hello.drv' failed with exit code 127;
       last 1 log lines:
       > /nix/store/yki5b3vqfzpwvkr6k7iwaxpmckfk3l2b-build-greeter-script.sh: line 4: mkdir: not found
       For full logs, run 'nix log /nix/store/d4yfycw4zb33d5syhzarcm7lcmk6y6yn-hello.drv'.
```

What? `mkdir: not found`? 

When Nix runs a builder program, it sets `PATH=/path-not-set` by default ([source]) and sandboxes the build so that derivations can't use OS-provided programs. In the first example, as only the `echo` command was used, it was able to run successfully. The standard core Unix utilities must be explicitly imported for the build to succeed. On the surface, not including standard Unix utilities in the default build environment may seem like a bug, but this is an intentional design decision to ensure reproducibility. Reproducible builds mean that Nix derivations work the same way on any machine. This is a key part of Nix's value proposition.

[source]: https://nixos.org/manual/nix/stable/language/derivations.html

Back to including the `mkdir` command. The standard [nixpkgs repository] has a [derivation] for [GNU coreutils]. Amend `hello-script.nix` to use the `coreutils`: 

[nixpkgs repository]:https://github.com/NixOS/nixpkgs
[derivation]: https://github.com/NixOS/nixpkgs/blob/ae8bdd2de4c23b239b5a771501641d2ef5e027d0/pkgs/tools/misc/coreutils/default.nix
[GNU coreutils]: https://www.gnu.org/software/coreutils/



```{code-block} nix
let pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/ae8bdd2de4c23b239b5a771501641d2ef5e027d0.tar.gz") {};
in

builtins.derivation {
    name = "hello";
    builder = ./build-greeter-script.sh;
    system = builtins.currentSystem;

    greeting = "Hello, World!";
    PATH = "${pkgs.coreutils}/bin";
}
```

The first two lines import nixpkgs into the scope as the variable `pkgs`. A specific commit is used for reproducibility. Notice how the `PATH` variable is set to the `bin` directory of the `coreutils` derivation. It also indicates to Nix that the `hello` derivation depends on the `coreutils` derivation

Running `nix-build` again, and it will download the `coreutils` from the public Nix cache before building the `hello` derivation:
```shell-session

$ nix-build hello-script.nix
this derivation will be built:
  /nix/store/0akibr7h4yyx1hmn1dnjn066gc4yixaw-hello.drv
these 8 paths will be fetched (9.16 MiB download, 40.92 MiB unpacked):
  /nix/store/2w4k8nvdyiggz717ygbbxchpnxrqc6y9-gcc-12.2.0-lib
  /nix/store/76l4v99sk83ylfwkz8wmwrm4s8h73rhd-glibc-2.35-224
  /nix/store/bg8f47vihykgqcgblxkfk9sbvc4dnksa-coreutils-9.1
  /nix/store/bw9s084fzmb5h40x98mfry25blj4cr9r-acl-2.3.1
  /nix/store/jn9kg98dsaajx4mh95rb9r5rf2idglqh-attr-2.5.1
  /nix/store/jvl8dr21nrwhqywwxcl8di4j55765gvy-gmp-with-cxx-stage4-6.2.1
  /nix/store/qmnr18aqd08zdkhka695ici96k6nzirv-libunistring-1.0
  /nix/store/vv6rlzln7vhxk519rdsrzmhhlpyb5q2m-libidn2-2.3.2
copying path '/nix/store/qmnr18aqd08zdkhka695ici96k6nzirv-libunistring-1.0' from 'https://cache.nixos.org'...
copying path '/nix/store/vv6rlzln7vhxk519rdsrzmhhlpyb5q2m-libidn2-2.3.2' from 'https://cache.nixos.org'...
copying path '/nix/store/76l4v99sk83ylfwkz8wmwrm4s8h73rhd-glibc-2.35-224' from 'https://cache.nixos.org'...
copying path '/nix/store/jn9kg98dsaajx4mh95rb9r5rf2idglqh-attr-2.5.1' from 'https://cache.nixos.org'...
copying path '/nix/store/2w4k8nvdyiggz717ygbbxchpnxrqc6y9-gcc-12.2.0-lib' from 'https://cache.nixos.org'...
copying path '/nix/store/bw9s084fzmb5h40x98mfry25blj4cr9r-acl-2.3.1' from 'https://cache.nixos.org'...
copying path '/nix/store/jvl8dr21nrwhqywwxcl8di4j55765gvy-gmp-with-cxx-stage4-6.2.1' from 'https://cache.nixos.org'...
copying path '/nix/store/bg8f47vihykgqcgblxkfk9sbvc4dnksa-coreutils-9.1' from 'https://cache.nixos.org'...
building '/nix/store/0akibr7h4yyx1hmn1dnjn066gc4yixaw-hello.drv'...
/nix/store/zgcm9jxccq0y9nnghppb2z996ig70q3c-hello
```

Now a small directory tree has been built:
```shell-session
$ cat result/bin/hello
#!/bin/sh
echo "Hello, World!"
$ result/bin/hello
Hello, World!
```

## Building GNU Hello

As we know how to bring derivations into the build environment, we will finish by packaging [GNU Hello], a C program that uses Autoconf and Make to print greetings to standard out. It has no dependencies beyond Make and common Unix tooling.

[GNU Hello]: https://www.gnu.org/software/hello/

As in the previous examples, first create a Bash script. This script will unpack a tarball, run `configure`, `make`, and `make install`. Save the following script into a file called `build-gnu-hello.sh` and `chmod +x build-gnu-hello.sh`:
```{code-block} bash

set -e 
tar zxf "$src"
cd hello-2.12.1
./configure --prefix="$out"
make
make install
```

Please notice that the source code is not downloaded in this script. Nix does not permit network access during most derivation's build process. Instead, the source code is downloaded by using [pkgs.fetchurl] from the nixpkgs repository and to check the hash of the downloaded file against the contents. This ensures that the build is working with known inputs, and thus keeps the build reproducible.

[pkgs.fetchurl]: https://nixos.org/manual/nixpkgs/unstable/#fetchurl


Create a new derivation called `gnu-hello1.nix`:
```{code-block} nix

# gnu-hello1.nix

let pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/ae8bdd2de4c23b239b5a771501641d2ef5e027d0.tar.gz") {};
in

builtins.derivation {
    name = "gnu-hello";
    builder = ./build-gnu-hello.sh;
    system = builtins.currentSystem;

    src = pkgs.fetchurl {
        url = "mirror://gnu/hello/hello-2.12.1.tar.gz";
        hash = "sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=";
    };
    PATH = "${pkgs.coreutils}/bin:${pkgs.gnused}/bin:${pkgs.gawk}/bin:${pkgs.gnugrep}/bin:${pkgs.gnutar}/bin:${pkgs.gzip}/bin:${pkgs.gcc9}/bin:${pkgs.gnumake}/bin";
}
```

Run `nix-build gnu-hello1.nix` followed by `result/bin/hello` like before. Because this downloads a lot more dependencies from the internet, the output is omitted here. The greeting is printed to standard out like in the previous examples. Verify that it is GNU Hello by running `result/bin/hello --version`.

While the above works, the nixpkgs repository has a wrapper function, `stdenv.mkDerivation`, that makes this easier. It includes [its own builder script], a [library] of utility functions, and runs phases provided by environment variables, and provides [common tooling for compiling C packages]. The [Standard Environment chapter] of the Nixpkgs manual has more information.

[its own builder script]: https://github.com/NixOS/nixpkgs/blob/ae8bdd2de4c23b239b5a771501641d2ef5e027d0/pkgs/stdenv/generic/default-builder.sh
[library]:https://github.com/NixOS/nixpkgs/blob/ae8bdd2de4c23b239b5a771501641d2ef5e027d0/pkgs/stdenv/generic/setup.sh
[common tooling for compiling C packages]:https://nixos.org/manual/nixpkgs/unstable/#sec-tools-of-stdenv
[Standard Environment chapter]:https://nixos.org/manual/nixpkgs/unstable/#chap-stdenv


Below the derivation is rewritten using `stdenv.mkDerivation`. This time, no builder script is needed. The Bash snippets are included as phases.

```{code-block} nix
# gnu-hello2.nix

let pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/ae8bdd2de4c23b239b5a771501641d2ef5e027d0.tar.gz") {};
in

pkgs.stdenv.mkDerivation {
    name = "hello";
    src = pkgs.fetchurl {
        url = "mirror://gnu/hello/hello-2.12.1.tar.gz";
        hash = "sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=";
    };

    configurePhase = "./configure --prefix=$out";
    buildPhase = "make";
    installPhase = "make install";
}
```

Building with `nix-build gnu-hello2.nix` it should produce another GNU Hello binary.

Since so many existing Unix programs follow this `./configure && make && make install` pattern, this is the default for `stdenv.mkDerivation`. Thus, the three last lines can be omitted:
```{code-block} nix
# gnu-hello3.nix

let pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/ae8bdd2de4c23b239b5a771501641d2ef5e027d0.tar.gz") {};
in

pkgs.stdenv.mkDerivation {
    name = "hello";
    src = pkgs.fetchurl {
        url = "mirror://gnu/hello/hello-2.12.1.tar.gz";
        hash = "sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=";
    };
}
```

Looking at the official [nixpkgs hello derivation], it's fairly similar, but has a few extra attributes for testing and metadata.

[nixpkgs hello derivation]:https://github.com/NixOS/nixpkgs/blob/ae8bdd2de4c23b239b5a771501641d2ef5e027d0/pkgs/applications/misc/hello/default.nix


## Summary
In this tutorial, we saw how to turn a Bash script into a Nix derivation and run it with `nix-build`. We also got a small taste of some of the utilities that Nix and nixpkgs give us at build time. Hopefully, this gave you a sense for how derivations work. 

(Once finished with this tutorial, you can remove the result symlink(s) and run `nix-store --gc` to reclaim the disk space used during this tutorial.)